---
title: Golang http包的大坑
date: '2020-05-25'
description: 
author: dashjay
---

### 今天一个小bug竟然影响了我那么久

大概是这样，我的整个http的repsonse已经被写入到buffer里了

```go
t := []byte(`HTTP/1.1 401 Unauthorized
Content-Length: 5605
Cache-Control: max-age=0, no-cache, no-store, must-revalidate
Connection: keep-alive
Content-Type: text/html; charset=utf-8
Date: Mon, 25 May 2020 12:43:48 GMT
Expires: Mon, 25 May 2020 12:43:48 GMT
Server: gunicorn/20.0.4
X-Frame-Options: SAMEORIGIN
......
 </body>`)
```

然后我尝试使用标准接口`http.ReadResponse`来解析这个包

```go
resp, err := http.ReadResponse(bufio.NewReader(bytes.NewBuffer(t)), nil)
if err != nil {
    panic(err)
}
```

解析出包之后我开始尝试去将body取出，有其他用途，我用了官方自带的`ioutil`里的`readall`这个函数

```go
content, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
```

这时候我发现会报EOF，我明明有body，然而我并没有去注视这个`ioutil.readall`，我从来没想过它会背叛我
官方注释这个接口的描述如下，`A successful call returns err == nil`也就是说确实报错了。

```go

// ReadAll reads from r until an error or EOF and returns the data it read.
// A successful call returns err == nil, not err == EOF. Because ReadAll is
// defined to read from src until EOF, it does not treat an EOF from Read
// as an error to be reported.
func ReadAll(r io.Reader) ([]byte, error) {
    return readAll(r, bytes.MinRead)
}
```

经过了几个小时的debug之后，我发现，原来问题在这，然后我换了一种写法。

```go
var body = make([]byte, resp.ContentLength)
_, err = resp.Body.Read(body)
if err != nil {
    panic(err)
    }
resp.Body.Close()
```

不出意外，可以了，我一整天的时间就这么消耗了？

不可能，我必须找出来为什么，首先一个请求返回字节流流式传输和我的从buffer中读取是没有什么区别的，当我把目光注视到`http.ReadResponse`的时候，我发现他会将`http.Request`作为参数，传入，为了一探究竟，我读了一下源代码。


先翻译一下注释，req这个参数可选择本返回值的请求，如果为nil则默认当做GET请求处理。
client必须调用resp.Body.Close当完成读取resp.Body之后。

```go
// ReadResponse reads and returns an HTTP response from r.
// The req parameter optionally specifies the Request that corresponds
// to this Response. If nil, a GET request is assumed.
// Clients must call resp.Body.Close when finished reading resp.Body.
// After that call, clients can inspect resp.Trailer to find key/value
// pairs included in the response trailer.
func ReadResponse(r *bufio.Reader, req *Request) (*Response, error) {
    ...
}
```

> 关于trailer写完本文我再去看


我发现http服务那边，是给textproto提供了池子的，说明这玩意频繁分配内存，消耗不小。但是这里http.ReadReponse和ReadRequest并没配备池子的原因，可能是因为使用频率比较小吧。

```go
tp := textproto.NewReader(r)
```

这里是用来提取第一行并且验证了合法性，例如 `HTTP/1.1 401 Unauthorized`

```go
// Parse the first line of the response.
line, err := tp.ReadLine()
if err != nil {
    if err == io.EOF {
        err = io.ErrUnexpectedEOF
        }
    return nil, err
}
if i := strings.IndexByte(line, ' '); i == -1 {
    return nil, &badStringError{"malformed HTTP response", line}
} else {
    resp.Proto = line[:i]
    resp.Status = strings.TrimLeft(line[i+1:], " ")
}
statusCode := resp.Status
if i := strings.IndexByte(resp.Status, ' '); i != -1 {
    statusCode = resp.Status[:i]
}
if len(statusCode) != 3 {
    return nil, &badStringError{"malformed HTTP status code", statusCode}
}
resp.StatusCode, err = strconv.Atoi(statusCode)
if err != nil || resp.StatusCode < 0 {
    return nil, &badStringError{"malformed HTTP status code", statusCode}
}
var ok bool
if resp.ProtoMajor, resp.ProtoMinor, ok = ParseHTTPVersion(resp.Proto); !ok {
    return nil, &badStringError{"malformed HTTP version", resp.Proto}
}
```

下面是用来读取MIME头的，类似于 `X-Forwarded-For: 111.111.111.111`

```go
// Parse the response headers.
mimeHeader, err := tp.ReadMIMEHeader()
if err != nil {
    if err == io.EOF {
    err = io.ErrUnexpectedEOF
    }
    return nil, err
}
resp.Header = Header(mimeHeader)
```

在下面有个

```go
err = readTransfer(resp, r)
if err != nil {
    return nil, err
}
```

这就是读取Body用的？，要套娃递归去看看了。

```go
switch rr := msg.(type) {
case *Response:
    ...
case *Request:
    ...
```

一进来似乎这个不只是Response独有的，Request也会用他来处理。

后面有似乎是处理一种叫做trailer的东西，平时没怎么听说过，查查资料在腾讯云文档找到一个

[腾讯云文档：Trailer](https://cloud.tencent.com/developer/section/1190006)

[腾讯云文档：Trailer-Encoding](https://cloud.tencent.com/developer/section/1190008)

```go
// Trailer
t.Trailer, err = fixTrailer(t.Header, t.TransferEncoding)
if err != nil {
    return err
}
```

我本来以为后面会有什么高超的技术用来处理body，后来我发现，并没有，他只是把没读完的textProto放进去当做body了，这下我知道为什么不用池了，因为，这个body知道被close才结束生命周期，而不是等函数返回

今天太累了，放着明早再写吧……为啥读不到呢。。。。
