---
title: 'MySQL 八股文'
date: '2020-11-05'
description: ''
author: 'dashjay'
---


> 有的面试官挺喜欢用自己那套规则来面试，搞的乌烟瘴气，全是背题的。

### Mysql 存储引擎

创建表格的时候指定

#### MyISAM

它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎

每一个表都有一个标志，来标注上次是否正常关闭。

MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。

MyISAM的表还支持3种不同的存储格式：

- 静态(固定长度)表：默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。
- 动态表：动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。
- 压缩表：压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。一般而言，如果你的系统是I/O瓶颈，那么可以使用CPU进行压缩与解压缩，以CPU换取I/O。

使用场景：

1. 做很多 count 的计算
2. 插入不频繁，查询非常频繁
3. 没有事务

#### InnoDB

InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

使用场景

1. 可靠性要求比较高，或者要求事务
2. 表更新和查询都相当的频繁，并且表锁定的机会比较大的情况

### 为什么使用 B+ 树

叶子节点才存放值，其他非叶子节点只存放 key，可以支持用最少的IO次数来定位目标。

### Mysql 数据库索引

这块八股文都比较复杂，还得专门找时间学习

### 数据库的事务特性

说道事务特性，还得说说四大特性：

- 原子性（Atomicity）：要么成功，要么失败回滚，失败的操作不允许对数据库造成任何影响
- 一致性（Consistency）：事务必须从一个状态转换到另一个状态，比如转账，A->B后，两个人的钱加起来总和不变
- 隔离性（Isolation）：隔离性是数据库为每个用户开启的事务，不能被其他事务干扰，如果两个并发的事务，T1和T2，相互感受不到对方对数据库的修改对自己的影响。
- 持久性（Durability）：一旦事务提交了，返回结果了，对数据库的修改就是永久的。

事务的隔离级别（默认级别为可重复读）

- 修改时允许修改（丢失更新）
- 修改时允许读取（脏读）
- 读取时允许修改（不可重复读）
- 读取时允许插入（幻读）

如果事务不隔离，就会出现以下几种问题：

1. 脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
2. 不可重复度：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
3. 幻读：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

### 数据库的四种事物的隔离级别

1. Read Uncommitted（读取未提交内容）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）

2. Read Committed（读取提交内容）：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果

3. Repeatable Read（可重读）：这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题

4. Serializable（可串行化）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

### 隔离性如何实现

有两个重要的办法，就是锁和MVCC

#### 锁🔐

读写锁：很常见不解释了

两段式提交锁：

第一个阶段只能加锁、或者释放锁
第二个阶段只会释放锁

具体需要很多其他的针对四种不同隔离级别具体分析TODO:

#### MVCC

加锁的方式会产生死锁问题。

对要操作的行标记一个版本号，然后再 update 或者 delete 操作的时候，拷贝一份副本，并且操作副本。

- innodb 对于 mvcc 的实现

事务ID会随着事件推移而增长，并且不可重复。对每一行保存两个版本号（更新操作的版本号、删除操作的版本号），这两个版本号的来源是事务的ID。

1. 对于 select 操作：每次只会 select 具有比当前事务ID更小的操作版本号的数据，而且这些数据要保证删除版本号为空，或者删除版本号大于大当前事务ID（改行并没有被删除）
2. 对于 update 操作：对该行数据复制出一份副本，同时在更新操作版本号写入当前事务ID，同时把当前ID写入之前的删除操作的版本号中。
3. 对于 insert 操作：写入新行，同时更新操作版本号中写入当前事务 ID
4. 对于 delete 操作：在操作版本号中写入当前事务 ID

### Mysql Explain

explain 一条 select 语句可以帮助你判断这次查询是否命中索引，是怎么样的扫描方式。

eq_ref > ref > range > index > ALL

- eq_ref: 主键索引(primary key)或者非空唯一索引(unique not null)等值扫描
- ref: 非主键非唯一索引等值扫描
- range：范围扫描
- index：索引树扫描
- ALL：全表扫描(full table scan)

### 行锁还是表锁

如果命中了索引，就可以只锁该行，如果没有命中或者，索引对应的行太多，就会锁整个表。
